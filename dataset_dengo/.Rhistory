K <- params[2]
dN <- r * N * (1 - N / K)
return(list(dN))
}
r <- 0.7
K <- 1000
params <- c(r, K)
temps <- seq(from = 0, to = 20, by = 0.02)
N0 <- seq(50, 1250, 50)
# Initialiser le graphique
sol <- ode(y = N0[1], times = temps, func = logistique, parms = params)
plot(sol[, "time"], sol[, "1"],
type = "l", ylim = c(0, 1300),
xlab = "Temps", ylab = "Population")
# Ajout des autres trajectoires
for (i in N0[-1]) {
sol <- ode(y = i, times = temps, func = logistique, parms = params)
lines(sol[, "time"], sol[, "1"], col = i/50)
}
######
# Q2 #
######
# Sur papier
######
# Q3 #
######
r <- 0.7
K <- 1000
E = 0.3
N0 = 5
h = 1
times = seq(0,20,h)
phi = function(ti, ui) {
return(r * ui * (1 - ui / K) - ui * E)
}
#1) Solution exacte
logist_expl = function(t){
return(((r-E)*K*N0)/(r*N0+(r*K-E*K-r*N0)*exp(-(r-E)*t)))
}
plot(times, sapply(times, logist_expl), type = "l", col="black")
#2) Schéma d'Euler
euler = c(N0, rep(0,length(times)-1))
for (i in 2:length(times)){
euler[i] = euler[i-1] + h * phi(times[i-1], euler[i-1])
}
lines(times, euler, col = "blue")
#3) Schema d'Euler amelioré
euler_ameliore = c(N0, rep(0,length(times)-1))
for (i in 2:length(times)){
euler_etoile = euler_ameliore[i-1] + (h/2) * phi(times[i-1], euler_ameliore[i-1])
euler_ameliore[i] = euler_ameliore[i-1] + h * phi(times[i], euler_etoile)
}
lines(times, euler_ameliore, col = "green")
#3) Schema d'Heun
heun = c(N0, rep(0,length(times)-1))
for (i in 2:length(times)){
heun[i] = heun[i-1] + (h/2) * (phi(times[i-1], heun[i-1]) + phi(times[i], euler[i]))
}
lines(times, heun, col = "skyblue")
#4) Schema de Runge-Kutta
RK4 = c(N0, rep(0,length(times)-1))
for (i in 2:length(times)){
p1 = phi(times[i], RK4[i-1])
p2 = phi((times[i]+h/2), RK4[i-1]+h/2*p1)
p3 = phi((times[i]+h/2), RK4[i-1]+h/2*p2)
p4 = phi((times[i]+h), RK4[i-1]+h*p3)
g = (p1+2*p2+2*p3+p4)/6
RK4[i] = RK4[i-1] + h*g
}
lines(times, RK4, col = "red")
#####
# Q4 et 5
#####
r <- 0.7
K <- 1000
E = 0.3
N0 = 5
h = 1
times = seq(0,20,h)
phi = function(ti, ui) {
return(r * ui * (1 - ui / K) - ui * E)
}
#1) Solution exacte
time0 = Sys.time()
logist_expl = function(t){
return(((r-E)*K*N0)/(r*N0+(r*K-E*K-r*N0)*exp(-(r-E)*t)))
}
sol = sapply(times, logist_expl)
plot(times, sol, type = "l", col="black")
time1 = Sys.time()
time_sol = difftime(time1,time0)
print(cat("time sol =", time_sol))
#2) Schéma d'Euler
diag_euler = function(h){
time0 = Sys.time()
euler = c(N0, rep(0,length(times)-1))
for (i in 2:length(times)){
euler[i] = euler[i-1] + h * phi(times[i-1], euler[i-1])
}
lines(times, euler, col = "blue")
time1 = Sys.time()
time_euler = difftime(time1,time0)
print(cat("time euler =", time_euler))
error_euler = sum(abs(sol-euler))
return(c(time_euler, error_euler))
}
#3) Schema d'Euler amelioré
diag_euler_ameliore = function(h){
time0 = Sys.time()
euler_ameliore = c(N0, rep(0,length(times)-1))
for (i in 2:length(times)){
euler_etoile = euler_ameliore[i-1] + (h/2) * phi(times[i-1], euler_ameliore[i-1])
euler_ameliore[i] = euler_ameliore[i-1] + h * phi(times[i], euler_etoile)
}
lines(times, euler_ameliore, col = "green")
time1 = Sys.time()
time_euler_ame = difftime(time1,time0)
print(cat("time euler amélioré =", time_euler_ame))
error_euler_ame = sum(abs(sol-euler_ameliore))
return(c(time_euler_ame, error_euler_ame))
}
#3) Schema d'Heun
diag_heun = function(h){
time0 = Sys.time()
heun = c(N0, rep(0,length(times)-1))
for (i in 2:length(times)){
heun[i] = heun[i-1] + (h/2) * (phi(times[i-1], heun[i-1]) + phi(times[i], euler[i]))
}
lines(times, heun, col = "turquoise")
time1 = Sys.time()
time_heun = difftime(time1,time0)
print(cat("time heun =", time_heun))
error_heun = sum(abs(sol-heun))
return(c(time_heun, error_heun))
}
#4) Schema de Runge-Kutta
diag_RK4 = function(h){
time0 = Sys.time()
RK4 = c(N0, rep(0,length(times)-1))
for (i in 2:length(times)){
p1 = phi(times[i], RK4[i-1])
p2 = phi((times[i]+h/2), RK4[i-1]+h/2*p1)
p3 = phi((times[i]+h/2), RK4[i-1]+h/2*p2)
p4 = phi((times[i]+h), RK4[i-1]+h*p3)
g = (p1+2*p2+2*p3+p4)/6
RK4[i] = RK4[i-1] + h*g
}
lines(times, RK4, col = "red")
time1 = Sys.time()
time_RK4 = difftime(time1, time0)
print(cat("time Runge-Kutta 4 =", time_RK4))
error_RK4 = sum(abs(sol-RK4))
return(c(time_RK4, error_RK4))
}
compute_exact <- function(h){
times <<- seq(0, 20, by = h)
sol <<- sapply(times, logist_expl)
}
h_list = c(1, 0.1, 0.01, 0.001, 0.0001, 0.00001)
results = data.frame(
h = numeric(),
methode = character(),
time = numeric(),
erreur = numeric()
)
for (h in h_list) {
compute_exact(h)
e1 = diag_euler(h)
results = rbind(results,
data.frame(h=h, methode="Euler",
time=as.numeric(e1[1]),
erreur=e1[2]))
e2 = diag_euler_ameliore(h)
results = rbind(results,
data.frame(h=h, methode="Euler amélioré",
time=as.numeric(e2[1]),
erreur=e2[2]))
e3 = diag_heun(h)
results = rbind(results,
data.frame(h=h, methode="Heun",
time=as.numeric(e3[1]),
erreur=e3[2]))
e4 = diag_RK4(h)
results = rbind(results,
data.frame(h=h, methode="RK4",
time=as.numeric(e4[1]),
erreur=e4[2]))
}
library(ggplot2)
ggplot(results, aes(x=h, y=erreur, color=methode)) +
geom_line() + geom_point() +
scale_x_log10() + scale_y_log10() +
labs(title="Erreur globale en fonction du pas de temps",
x="Pas de temps h",
y="Erreur (norme L1)") +
theme_minimal()
compute_exact <- function(h){
times <<- seq(0, 20, by = h)
sol <<- sapply(times, logist_expl)
}
h_list = c(1, 0.1, 0.01, 0.001, 0.0001, 0.00001)
results = data.frame(
h = numeric(),
methode = character(),
time = numeric(),
erreur = numeric()
)
for (h in h_list) {
compute_exact(h)
e1 = diag_euler(h)
results = rbind(results,
data.frame(h=h, methode="Euler",
time=as.numeric(e1[1]),
erreur=e1[2]))
e2 = diag_euler_ameliore(h)
results = rbind(results,
data.frame(h=h, methode="Euler amélioré",
time=as.numeric(e2[1]),
erreur=e2[2]))
e3 = diag_heun(h)
results = rbind(results,
data.frame(h=h, methode="Heun",
time=as.numeric(e3[1]),
erreur=e3[2]))
e4 = diag_RK4(h)
results = rbind(results,
data.frame(h=h, methode="RK4",
time=as.numeric(e4[1]),
erreur=e4[2]))
}
library(ggplot2)
ggplot(results, aes(x=h, y=erreur, color=methode)) +
geom_line() + geom_point() +
scale_x_log10() + scale_y_log10() +
labs(title="Erreur globale en fonction du pas de temps",
x="Pas de temps h",
y="Erreur (norme L1)") +
theme_minimal()
warnings()
View(results)
######
# Q6 #
######
compute_exact <- function(h){
times <- seq(0, 20, by = h)
sol <- sapply(times, logist_expl)
}
h_list = c(1, 0.1, 0.01, 0.001, 0.0001, 0.00001)
results = data.frame(
h = numeric(),
methode = character(),
time = numeric(),
erreur = numeric()
)
for (h in h_list) {
compute_exact(h)
e1 = diag_euler(h)
results = rbind(results,
data.frame(h=h, methode="Euler",
time=as.numeric(e1[1]),
erreur=e1[2]))
e2 = diag_euler_ameliore(h)
results = rbind(results,
data.frame(h=h, methode="Euler amélioré",
time=as.numeric(e2[1]),
erreur=e2[2]))
e3 = diag_heun(h)
results = rbind(results,
data.frame(h=h, methode="Heun",
time=as.numeric(e3[1]),
erreur=e3[2]))
e4 = diag_RK4(h)
results = rbind(results,
data.frame(h=h, methode="RK4",
time=as.numeric(e4[1]),
erreur=e4[2]))
}
library(ggplot2)
ggplot(results, aes(x=h, y=erreur, color=methode)) +
geom_line() + geom_point() +
scale_x_log10() + scale_y_log10() +
labs(title="Erreur globale en fonction du pas de temps",
x="Pas de temps h",
y="Erreur (norme L1)") +
theme_minimal()
#setwd("~/Documents/Master/M2/MEPI/projet/MEPI_dengue/dataset_dengo")
setwd("C:/Users/Nitro/Documents/Cours/MEPI_dengue/dataset_dengo")
# Import
#devtools::install_github("GaelBn/BRREWABC")
library(BRREWABC)
library(deSolve)
setwd("~/Documents/Master/M2/MEPI/projet/MEPI_dengue/dataset_dengo")
# Import
#devtools::install_github("GaelBn/BRREWABC")
library(BRREWABC)
library(deSolve)
# Import datasets
data19 <- read.csv(
file = "dengue_2019.csv",
header = TRUE,
sep = ",",
dec = ".",
)
data20 <- read.csv(
file = "dengue_2020.csv",
header = TRUE,
d = ",",
dec = "."
)
data20 <- read.csv(
file = "dengue_2020.csv",
header = TRUE,
d = ",",
dec = "."
)
# Import datasets
data19 <- read.csv(
file = "dengue_2019.csv",
header = TRUE,
sep = ",",
dec = ".",
)
data20 <- read.csv(
file = "dengue_2020.csv",
header = TRUE,
sep = ",",
dec = "."
)
data21 <- read.csv(
file = "dengue_2021.csv",
header = TRUE,
sep = ",",
dec = "."
)
################ Déterministe ####################
modele_dengue_deter=function(t,y,param){
# Définition des paramètres à opimiser
beta_h = param[1]
# Définition des paramètres fixés
z = 2.5
gamma = 1 / 2
beta_v = 0.375
mu_v = 1 / 6
# Définition des classes de population
# Humains
Ih = y[1]
Rh = y[2]
Nh = 10000
# Moustiques
Iv = y[3]
Nv = z * Nh
# Définition des dérivées
dIdt = -gamma * Ih + beta_h * z * Iv  * (Nh - Ih - Rh) / Nh
dRdt = gamma * Ih
dVdt = beta_v * (Nv - Iv) * Ih/Nh - mu_v * Iv
return(list(c(dIdt, dRdt, dVdt)))
}
simulation_deter=function(y,tmax,param,delta_t){
# Definition du pas de temps
temps=seq(0,tmax,delta_t)
# Résolution de l'équation
result=ode(y=y,times=temps,func=modele_dengue_deter,parms=param,method="rk4")
# Visualisation
par(mfrow=c(1,2))
plot(result[,1],result[,3],type="l",col="blue",ylim=c(0,10000))
lines(result[,1],result[,2],type="l",col="red")
plot(result[,1],result[,4],type="l")
return(result)
}
distance_deter=function(param,ssobs){
# Définition des conditions initiales
y0=c(100,0,100)
# Simulation de la trajectoire
simu=simulation_deter(y=y0, tmax=360, param=param, delta_t=1) # On considère grossièrement que chaque mois -> 30 jours
infected_dyna=simu[,2]
recover_dyna=simu[,3]
# Création d'un résumé de nos statistiques simulées
all_mensual_case
# Comparaison de nos statistiques résumées
}
# Juste un test que ça fonctionne correctement, la dynamique ressemble à quelque chose qui me semble logique vu notre modèle
# Tu me diras si de ton coté aussi
test=simulation_deter(c(100,100,100),60,c(0.65),1)
################################
#~~~HARDY Erwan et FRITZ Leo~~~#
################################
################################################################################
# Script pour l'étude d'une épidemie de dengue au Sri Lanka entre 2019 et 2022 #
# Prise en compte des migrations inter-urbaines et de la pluviométrie à        #
# l'échelle des districts administratifs.                                      #
################################################################################
#setwd("~/Documents/Master/M2/MEPI/projet/MEPI_dengue/dataset_dengo")
setwd("C:/Users/Nitro/Documents/Cours/MEPI_dengue/dataset_dengo")
################################
#~~~HARDY Erwan et FRITZ Leo~~~#
################################
################################################################################
# Script pour l'étude d'une épidemie de dengue au Sri Lanka entre 2019 et 2022 #
# Prise en compte des migrations inter-urbaines et de la pluviométrie à        #
# l'échelle des districts administratifs.                                      #
################################################################################
setwd("~/Documents/Master/M2/MEPI/projet/MEPI_dengue/dataset_dengo")
#setwd("C:/Users/Nitro/Documents/Cours/MEPI_dengue/dataset_dengo")
# Import
#devtools::install_github("GaelBn/BRREWABC")
library(BRREWABC)
library(deSolve)
# Import datasets
data19 <- read.csv(
file = "dengue_2019.csv",
header = TRUE,
sep = ",",
dec = ".",
)
data20 <- read.csv(
file = "dengue_2020.csv",
header = TRUE,
sep = ",",
dec = "."
)
data21 <- read.csv(
file = "dengue_2021.csv",
header = TRUE,
sep = ",",
dec = "."
)
################ Déterministe ####################
modele_dengue_deter=function(t,y,param){
# Définition des paramètres à opimiser
beta_h = param[1]
# Définition des paramètres fixés
z = 2.5
gamma = 1 / 2
beta_v = 0.375
mu_v = 1 / 6
# Définition des classes de population
# Humains
Ih = y[1]
Rh = y[2]
Nh = 10000
# Moustiques
Iv = y[3]
Nv = z * Nh
# Définition des dérivées
dIdt = -gamma * Ih + beta_h * z * Iv  * (Nh - Ih - Rh) / Nh
dRdt = gamma * Ih
dVdt = beta_v * (Nv) * Ih/Nh - mu_v * Iv
return(list(c(dIdt, dRdt, dVdt)))
}
simulation_deter=function(y,tmax,param,delta_t){
# Definition du pas de temps
temps=seq(0,tmax,delta_t)
# Résolution de l'équation
result=ode(y=y,times=temps,func=modele_dengue_deter,parms=param,method="rk4")
# Visualisation
par(mfrow=c(1,2))
plot(result[,1],result[,3],type="l",col="blue",ylim=c(0,10000))
lines(result[,1],result[,2],type="l",col="red")
plot(result[,1],result[,4],type="l")
return(result)
}
# Juste un test que ça fonctionne correctement, la dynamique ressemble à quelque chose qui me semble logique vu notre modèle
# Tu me diras si de ton coté aussi
# test=simulation_deter(c(100,100,100),60,c(0.65),1)
# Idée : on fait un modele stochastique où beta est fixé mais on inclus le a_i
# comme dans le papier sur lequel on se base.
distance_deter=function(param,ssobs){
# Définition des conditions initiales
y0=c(100,0,100)
# Simulation de la trajectoire
simu=simulation_deter(y=y0, tmax=360, param=param, delta_t=1) # On considère grossièrement que chaque mois -> 30 jours
infected_dyna=simu[,2]
recover_dyna=simu[,3]
# Création d'un résumé de nos statistiques simulées
all_mensual_case
# Comparaison de nos statistiques résumées
}
############# Stochastique ###############
modele_dengue_stoch=function(Sh0,Ih0,Rh0,Sv0,Iv0,param,tmax){
Sh=Sh0
Ih=Ih0
Rh=Rh0
Nv=2*Sh0 #Nombre de moustique par habitant à définir
Iv=0.2*Nv #Proportion de moustique porteur à définir
Sv=Nv-Iv
betah=param[1]
gamma=param[2]
betav=param[3]
for (i in 1:tmax){
# Définition des taux de transmission
tx_transmi_h =
tx_transmi_v =
tx_recovery =
# Définition des probas de transmissions
pb_inf_h = 1 - exp(-tx_transmi_h)
pb_inf_v = 1 - exp(-tx_transmi_v)
pb_recov = 1 - exp(-tx_recovery)
# Tirage des individus transitionnant
new_inf_v = rbinom(Sh, pb_inf_h)
new_inf_h = rbinom(Sv, pb_inf_v)
new_recov = rbinom(Ih, pb_recov)
# Ajout des individus transitionnant
Sh = Sh - new_inf_h
Ih = Ih + new_inf_h - new_recov
Rh = Rh + new_recov
Sv = Sv - new_inf_v
Iv = Iv + new_inf_v
}
}
# Juste un test que ça fonctionne correctement, la dynamique ressemble à quelque chose qui me semble logique vu notre modèle
# Tu me diras si de ton coté aussi
test=simulation_deter(c(100,100,100),60,c(0.65),1)
